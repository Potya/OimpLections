// Сегодня мы поговорим про идиому RAII (Resource aquitization is initialization).
// Переводится это как "выделение ресурса должно быть инициализацией".
// Идея в том, что если у нас есть какой-то ресурс (память, файл, мьютекс и т. д.),
// который надо обязательно "вернуть", когда он будет уже ненужен,
// то лучше всего запрашивать этот ресурс в конструкторе некоторого объекта,
// а освобождать - в деструкторе.

// Рассмотрим хрестоматийный пример ресурса: файл.
// Как работали с файлами в языке С?
// Работа с файлами осуществлялась через файловый дескриптор. Это был просто указатель на специальную структуру FILE:

#include <cstdio>

int main() {
    FILE * f = fopen("a.txt", "r");  // открываем файл a.txt для чтения и получаем его дескриптор
    if (f != nullptr) {  // если дескриптор не является нулевым указателем, то файл успешно окрыт
        char buf[100];
        fscanf(f, "%s", buf);  // считываем из файла текст в буфер (наивно предполагая, что 99 символов нам хватит)
        // ...
        fclose(f);  // закрываем файл
    } else {
        std::cout << "Ошибка при открытии файла!\n";
    }
}

// В куске кода, обозначенном многоточием, тоже может быть много аварийных ситуаций. 
// В каждой из них надо не забыть закрыть файл. Код с такими проверками становится очень громоздким.


// Следуя идиоме RAII, мы бы "обернули" файл в объект специального класса.
// Тогда открытие файла соответствовало бы инициализации объекта в его конструкторе,
// а закрытие файла - уничтожению объекта в деструкторе.

// В случае ошибки при открытии файла мы бы сгенерировали исключение, и объект нашего класса не был бы создан.

#include <exception>  // для std::exception
#include <string>

class CannotOpenFileException: std::exception {
};

class File {
private:
    FILE * f;  // тот самый файловый дескриптор, который мы оборачиваем

public:
    File(const char * name) {
        f = fopen(name, "r");
        if (f == nullptr)
            throw CannotOpenFileException();  // генерировать исключения в конструкторах - это нормально!
    }

    ~File() {
        if (f != nullptr)
            fclose(f);
    }

    std::string Read() const {
        char buf[100];
        fscanf(f, "%s", buf);
        return buf;
    }
};


// Теперь можно работать так:
int main() {
    try {
        File f("a.txt");
        const auto& str = f.Read();
        // ...
    } catch (const CannotOpenFileException&) {
        std::cout << "Ошибка при открытии файла!\n";
    }
}

// Что бы ни произошло в строках с многоточием, для объекта f всегда будет вызван деструктор, а значит, файл будет корректно закрыт.


// Правда, нас пока подстерегают те же проблемы с копированием и присваиванием, что и с матрицей в прошлый раз:

File f1("a.txt");
File f2 = f1;  // конструктор копирования
File f3("b.txt");
f3 = f1;  // оператор присваивания

// Все три этих объекта хранят один и тот же файловый дескриптор.
// Возможно, тут будет разумным просто запретить такое копирование и присваивание.
// Это можно сделать хотя бы так:

class File {
    File(const File&) = delete;  // запрещаем компилятору автоматически генерировать конструктор копирования
    File& operator = (const File&) = delete;  // и оператор присваивания
    // ...
};


// Но всё-таки хочется, чтобы вот такой код был допустимым:

File GetFile() {
    return File("a.txt");
}

int main() {
     File f = GetFile();  // сейчас не сработает - конструктор копирования запрещён!
     // ...
}

// В отличие от предыдущего примера с копированием, здесь копируется временный объект - результат функции GetFile.
// Для таких объектов в C++11 предусмотрены особые rvalue-ссылки.
// Можно просто написать конструктор перемещения, который заберет данные из такого объекта:

class File {
    File(const File&) = delete;  // запрещаем компилятору автоматически генерировать конструктор копирования
    File& operator = (const File&) = delete;  // и оператор присваивания

    File(File&& other) {  // File&& - ссылка на временный объект
        f = other.f;
        other.f = nullptr;  // забираем владение дескриптором у временного объекта
    }

    File& operator = (File&& other) {
        if (f != nullptr)
            fclose(f);
        f = other.f;
        other.f = nullptr;
        return *this;
    }

    // ...
};


// В стандартной библиотеке уже есть готовая обёртка над файловыми дескрипторами std::fstream,
// позволяющая работать с файлами как с потоками ввода-вывода. Пользуйтесь ей.

