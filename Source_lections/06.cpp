// Сегодня мы продолжим изучать алгоритмы стандартной библиотеки
// Подробное описание можно посмотреть на http://en.cppreference.com/w/cpp/algorithm
// Напомню, что алгоритмы описаны в виде шаблонных функций,
// обрабатывающих последовательности, заданные в виде пары итераторов.
// Пара итераторов [first; last) всегда ограничивает полуинтервал (правый конец не включается).
// Поэтому, например, если два итератора равны, то они обозначают пустой интервал.

// Обычно алгоритмы делят на два больших класса:
// алгоритмы, модифицирующие последовательность, и немодифицирующие алгоритмы.

// Пример: алгоритм for_each.
// Он выполняет заданную функцию (или функтор) для каждого элемента последовательности.
// Вот его возможная реализация:

template <typename It, typename F>
F for_each(It first, It last, F f) {
    while (first != last) {
        f(*first);
        ++first;
    }
    return f;
}

// Обратите внимание: функцию f (точнее, то, что можно вызвать как функцию)
// мы передаём просто как параметр шаблонного типа F.
// Компилятор сам угадает этот тип при каждом конкретном вызове for_each.
// Не надо тут пытаться писать вместо F f что-то вроде void (*f)(const T&).

// Этот алгоритм был особенно популярен до C++11, когда в языке ещё не было range-based for.

// Приведём пример: напечатаем элементы контейнера map на экране различными способами

#include <algorithm>
#include <iostream>
#include <map>
#include <string>

using namespace std;

void print(const pair<const string, int>& pair) {
    cout << pair.first << "\t" << pair.second << "\n";
}

int main() {
    map<string, int> freqs;
    // заполняем freqs

    // I способ: range-based for:
    for (const auto& pair : freqs)
         cout << pair.first << "\t" << pair.second << "\n";

    // II способ: используем итераторы
    for (auto it = freqs.cbegin(); it != freqs.cend(); ++it) {
        const auto& pair = *it;  // фактически предыдущий способ разворачивается в это
        cout << pair.first << "\t" << pair.second << "\n";
    }

    // III способ: for_each с отдельной функцией:
    for_each(freqs.begin(), freqs.end(), print);
   
    // IV способ: for_each с лямбда-функцией:
    for_each(
        freqs.begin(), 
        freqs.end(), 
        [](const pair<const string, int>& pair) {
            cout << pair.first << "\t" << pair.second << "\n";
        }
    );
}

// Вот ещё один изощрённый способ ввода/вывода (правда, работать он будет только с последовательным контейнером)
#include <algorithm>
#include <iostream>
#include <iterator>
#include <list>

using namespace std;

int main() {
    list<int> data;  // двусвязный список

    // Ввод
    copy(
        istream_iterator<int>(cin),  // специальный итератор, связанный с потоком ввода
        istream_iterator<int>(),  // условный итератор, обозначающий конец ввода
        back_inserter(data)  // адаптер, прикидывающийся итератором: при попытке разыменования выполняет push_back
    );

    // Вывод через табуляцию
    copy(
        data.begin(),
        data.end(),
        ostream_iterator<int>(cout, "\t")  // специальный итератор, связанный с потоком вывода
    );
}

// Обратите внимание, что мы не могли бы написать вот так:

list<int> data;
copy(
    istream_iterator<int>(cin),
    istream_iterator<int>(),
    data.begin()  // тут будет ошибка в runtume!
);

// Дело в том, что все алгоритмы предполагают, что в контейнере уже выделено достаточно места, чтобы записать данные.
// А у нас список изначально был пустым. Поэтому произойдёт "проезд по памяти".
// Надо было либо перед копированием сделать resize (если известно, сколько будет элементов),
// либо использовать back_inserter.

// Фактически back_inserter - это шаблонная функция, возвращающая объект класса back_insert_iterator<list<int>>,
// который притворяется обычным итератором, но при попытке присваивания выполняет push_back в соотвествующий контейнер.

// Поэтому код функции copy (мы его писали на прошлом занятии)
template <typename InputIterator, template OutputIterator>
OutputIterator copy(
    InputIterator first,
    InputIterator last,
    OutputIterator copy
) {
    while (first != last)
        *out++ = *first++;
    return out;
}

// превратится при использовании back_inserter'а во что-то такое:
while (first != last)
    data.push_back(*first++);

// Хорошее упражнение: написать свою версию back_inserter'а самостоятельно.


// Познакомимся теперь с алгоритмом remove_if.
// Он переупорядочивает элементы последовательности, "затирая" те из них, которые удовлетворяют предикату.
// Заметьте, что алгоритмы работают с итераторами (а не с самим контейнером).
// Итераторы же предоставляют логический, а не физический доступ к последовательности.
// Поэтому алгоритмы не могут физически удалить элемент из контейнера.
// В частности, размер контейнера после работы алгоритма не может измениться.
// Максимум, что могут сделать алгоритмы - это перезаписать значения элементов.

// Чтобы физически удалить данные из контейнера, надо воспользоваться функцией erase в самом контейнере:

#include <algorithm>
#include <vector>

using namespace std;

int main() {
    std::vector<int> v;
    // ...
    v.erase(
        remove_if(  // оставляем в левой части вектора только нечётные элементы
            v.begin(),
            v.end(),
            [](int x) {
                return x % 2 == 0;
            }
        ),  // remove_if возвращает итератор, указывающий за последний оставшийся элемент. Дальше - мусор
        v.end()
      );  // удаляем этот мусор с помощью erase.
}


// Аналогичный пример - функция unique.
// Эта функция переупорядочивает элементы вектора так,
// чтобы из группы подряд идущих одинаковых элементов оставался только один
// (а в конце остался бы "мусор")
// Часто её применяют вместе с sort, чтобы удалить дубликаты:

#include <algorithm>
#include <vector>

using namespace std;

int main() {
    std::vector<int> v;
    // ...
    sort(v.begin(), v.end());

    v.erase(
        unique(v.begin(), v.end()),
        v.end()
    );
}

