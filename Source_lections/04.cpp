// Сегодня мы поговорим о структурах.
// Структура в первом приближении - это созданный пользователем тип данных, 
// объединяющий несколько переменных (полей) "под одной крышей"
// В C++ структуры и классы почти ничем не отличаются
// (все члены структур по умолчанию открыты, а в классе - закрыты).
// Но мы будем использовать слово "структура", когда не будем хотеть от этого типа ничего другого,
// кроме объединения полей. 
// Мы не будем пока определять функции-члены структуры, писать конструкторы и деструкторы, перегружать операторы и т. д.
// Всё это мы, конечно, будем проходить, но чуть позже. И будем говорить тогда не "структура", а "класс".
// А сейчас "структура" для нас - это POD (plain old data, "старые добрые данные") - есть такой термин в C++-жаргоне.

#include <string>
#include <vector>
#include <iostream>

// Дата задаётся днём, месяцем и годом.
// По отдельности эти величины таскать неудобно. Объединим их в структуру.
struct Date {
    int Day;
    int Month;
    int Year;
}; // обратите внимание на эту точку с запятой, она нужна.

// Студент, например, описывается именем и фамилией, датой рождения, годом поступления и рейтингом.
struct Student {
    std::string Name;
    std::string Surname;
    Date Birthday; // тип этого поля - структура, определенная выше
    int Year;
    double Rating;
};

int main() {
    Date d1 {23, 10, 2015}; // инициализируем поля структуры в порядке их объявления

    Date d2;
    d2.Day = 23; // Но можно было бы присвоить им значения и вот так
    d2.Month = 10;
    d2.Year = 2015;

    Student s { // описываем студента
        "Ivan",
        "Ivanov",
        d1, // это его дата рождения; можно было бы также написать {23, 10, 2015} 
        2015,
        10.0
    };

    // Допустим, надо считать данные о студентах с клавиатуры. Сделаем примерно так
    size_t N;
    std::cin >> N; // узнаём, сколько будет студентов
    std::vector<Student> students(N); // создаём вектор "пустых" студентов размера N
    for (auto& s : students) { // можно было бы написать Student& вместо auto&. Благодаря ссылке значение s можно изменять.
        std::cin >> s.Name >> s.Surname; // считываем фамилию и имя очередного студента
    }
    const auto& x = students.back(); // берём последнего студента с помощью константной ссылки
    // (можно было бы написать const Student& вместо const auto&)
    // Если бы мы написали вот так
    Student у = students.back(); // или auto у = students.back()
    // то x было бы "копией" элемента вектора. А лишнее копирование большой структуры нам ни к чему.
}

// Как отсортировать студентов? Для этого надо научиться их попарно сравнивать.
// Можно определить поведение оператора < для студентов:
bool operator < (const Student& a, const Student& b) {
    if (a.Rating != b.Rating)
        return a.Rating > b.Rating; // сравниваем сначала по рейтингу (в порядке убывания)
    else
        return a.Surname < b.Surname; // затем - по фамилии
}

// отсортировать теперь можно так:
#include <algorithm> // надо подключить этот заголовок вверху
// ...
std::sort(students.begin(), students.end());

// Обратите внимание, мы передавали параметры в operator < по константной ссылке.
// Можно было бы написать
bool operator < (Student a, Student b);
// но тогда бы происходило лишнее копирование параметров при каждом входе в функцию.
// Копировать объект типа Student - дорого.
// Во-первых, он содержит строки, копирование которых повлечет новое выделение памяти.
// Во-вторых, он сам по себе занимает много места (больше, чем ссылка).


// Перегрузим оператор >> для ввода данных о студенте со стандартного потока ввода:
istream& operator >> (istream& in, Student& student) {
    in >> student.Surname >> student.Name;
    return in;
}

// Здесь in - ссылка на поток ввода (например, cin).
// Эта же ссылка возвращается из функции, чтобы можно было писать каскадные цепочки вида cin >> x >> y.

int main() {
    Student student;
    cin >> student;
    
    cout << student << "\n";
    
    cout << student.Surname << " " << student.Name  << "\n";
    // Упражнение: напишите по аналогии operator <<, чтобы можно было бы писать cout << student << "\n";
}


// Познакомимся теперь с "ассоциативными массивами" - контейнерами, ключом в которых служит не целочисленный индекс,
// а произвольный объект заданного типа.
// Начнём с контейнера map.

#include <map>
#include <string>

int main() {
    // Контейнер map: внутри - красно-чёрное дерево.
    // Сложность операций поиска, вставки и удаления логарифмическая.
    map<string, int> data;  // на ключах должен быть определен оператор <

    data.insert("hello", 1);  // вставили значение
    data.insert("hello", 42);  // перезаписали значение, ассоциированное с ключом hello

    data["hell"];  // внезапно: не нашли такого ключа, поэтому на лету вставили его со значением по умолчанию (0)

    data["hello"] += 1;
    data["good bye"] = 100;

    auto it = data.find("hell");  // проверяем, есть ли такой ключ
    if (it == data.end()) {  // если его нет, то возвращаемый итератор совпадает с data.end()
        cout << "Not found!\n";
        return 0;
    }
    // в противном случае итератор можно "разыменовать", обратившись к найденной паре (ключ, значение)
    cout << "Found: " << it->first
         << "\t" 
         << it->second 
         << "\n";

    for (const auto& elem : data) {  // все элементы выводятся в отсортированном по ключам порядке
        cout << elem.first 
             << "\t"
             << elem.second
             << "\n";
    }
}


// Типичная задача - подсчитать частоты разных символов в строке
// а затем вывести эти символы по убыванию частоты (а в случае равных частот - по алфавиту)
#include <algorithm>
#include <iostream>
#include <map>
#include <string>
#include <vector>

using namespace std;

int main() {
    string line;
    getline(cin, line);

    map<char, int> freq;
    for (char c : line)
        ++freq[c];

    // Пары изначально отсортированы по символам
    // Копируем пары в вектор, чтоб затем отсортировать их по частотам
    vector<pair<char, int>> items(  // конструкторы стандартных контейнеров умеют инициализироваться парой итераторов
        freq.begin(),
        freq.end()
    );

    // Используем stable_sort, чтобы лексикографический порядок пар с одинаковой частотой не изменился
    stable_sort(
        items.begin(),
        items.end(),
        [](const pair<char, int>& a,
           const pair<char, int>& b) {
               return a.second > b.second;
           }
    );

    for (const auto& item : items) {
        cout << item.first << "\t" << item.second << "\n";
    }
 
}

// Другие похожие контейнеры - это
// -- std::unordered_map (хеш-таблица, средняя сложность операций O(1));
// -- std::multimap (мультиассоциативный массив, разрешается иметь много значений при ключах);
// -- std::set (множество: считайте, что это map с проигнорированными значениями);
// -- std::multiset (мультимножество)
// -- std::unordered_multimap (мульти-хеш-таблица);
// -- std::unordered_set (хеш-множество);
// -- std::unordered_multiset (мульти-хеш-множество).
