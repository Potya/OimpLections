// Приоритет операторов
// Рассмотрим вот эту таблицу:
// http://en.cppreference.com/w/cpp/language/operator_precedence

// Поговорим про некоторые операторы из этой таблицы

// Постфиксный и префиксный инкремент/декремент. В чем разница?

int a = 0, b = 0;

a++;
++b;

// Разница в том, какое значение у этих выражений. Представим, что мы их присваиваем чему-либо:

int a = 0, b = 0;
int c = a++; // a == 1, c == 0
int d = ++b; // b == 1, d == 1

// Постфиксный оператор возвращает старое значение переменной (до изменения).
// Префиксный - возвращает ссылку на измененную переменную.

// Это можно представить себе примерно так (это не настоящий C++!):

// ++a
a = a + 1;
return a;

// a++
int temp = a;
a = a + 1;
return temp;

// Для типа int разница не столь существенна.
// Но для более сложных типов (например, итераторов), поддерживающих ++ и --, разница может быть ощутима.
// Поэтому придерживайтесь следующего правила: всегда старайтесь использовать префиксный ++ или -- вместо постфиксного


// В постфиксном случае возвращается временное значение. Ему уже нельзя ничего присвоить. Поэтому вот такая конструкция незаконна:
a++++;

// А вот такая - сработает:
++++a; // это не четыре унарных плюса, а два "плюс плюса" - компилятор старается откусывать максимально возможный токен на каждом шаге.

// Из таблицы приоритета видно, что постфиксные операторы всегда имеют приоритет над префиксными. Запомните это!

int a = 0;
++a++; // поэтому вот это не скомпилируется

int b = 0;
(++b)++; // а вот это - уже скомпилируется. Результат выражения будет 1, а b станет равным 2.



// Обратите внимание, что среди постфиксных операторов
// есть оператор вызова функции (круглые скобки, не путать их со скобками приоритета!)
// и оператор обращения по индексу (квадратные скобки)


// Обратите внимание, что в таблице приоритета операторов указана ассоциативность (слева направо или справа налево).
// Она определяет, как расставлять скобки в выражениях с несколькими операторами.
// Например, для операторов присваивания ассоциативность указана справа налево

int a, b, c, d;
a = b = c = d = 0; // поэтому скобки расставятся так: a = (b = (c = (d = 0)));

// Кстати, оператор присваивания всегда возвращает ссылку на тот объект, которому присваивали.
// Поэтому мы и можем писать такие цепочки.



// Тернарный оператор ?:

int x;
std::cin >> x;
int y = x >= 0 ? x : -x;



// Самый низкий приоритет - у оператора "запятая".
// Он просто вычисляет сначала левую часть, потом правую. Результат равен правой части.

// Вот пример использования:

for (x = something, y = something_else; x < N; ...) {
   ...
}

// Только не попадитесь в ловушку!

int x, y;
std::cin >> x, y; // Ошибка, которую вы не сразу заметите!
std::cin >> (x, y); // Тоже ошибка! Разберитесь, что делают эта и предыдущая строки.



// Поговорим теперь про функции
// Напишем два варианта вычисления НОД по алгоритму Евклида:

#include <iostream>

int gcd(int a, int b) {
    while (b != 0) {
    	int r = a % b;
    	a = b;
    	b = r;
    }
    return a;
}

int gcd_recursive(int a, int b) {
    if (b != 0)
    	return gcd_recursive(b, a % b);
    return a;
}

int main() {
    int x, y;
    std::cin >> x >> y;
    std::cout << gcd(x, y) << "\n"; // обратите внимание, что вызов функции - тоже оператор
    std::cout << gcd_recursive(x, y) << "\n";
}


// Если функция не должна ничего возвращать, то объявите ее как void:

void do_something(int a) {
    // ...
}

// Заметьте, что параметры по умолчанию передаются в функцию "по значению".
// Это значит, что при входе в функцию создается их копия.
// Изменение таких параметров внутри функции незаметна в вызывающей программе.

void foo(int a) {
    ++a;
}

int main() {
    int x = 0;
    foo(x);
    std::cout << x << "\n"; // напечатает 0, а не 1
}


// Иногда бывает нужно изменить параметр, переданный в функцию.
// Для этого его можно передать "по ссылке":

void foo(int& a) { // параметр передается по ссылке
    ++a;
}

int main() {
    int x = 0;
    foo(x);
    std::cout << x << "\n"; // напечатает 1
}

// Некоторый недостаток этого подхода - в точке вызова foo(x) не видно сразу, может ли измениться этот параметр, или нет.


// Старый способ (который был в C) изменения аргумента фукнции - передать параметр "по указателю":

void foo(int * a) { // функция принимает указатель на участок памяти, содержащий значение типа int
    ++*a; // увеличиваем значение в области памяти, на которую ссылается a
}

int main() {
    int x = 0;
    foo(&x); // передаем в функцию адрес переменной x
    std::cout << x << "\n"; // напечатает 1
}

// Про указатели будет позже отдельный рассказ.


// Пусть теперь мы хотим передать в функцию какой-нибудь тяжелый объект - строку или вектор.
// "Тяжелый" - значит, что его долго и дорого копировать.
// Поэтому вот так делать неоправданно, если мы не хотим изменять внутри функции копию строки s

void is_palindrome(std::string s) { // тут происходит неоправданное и ненужное копирование строки s
    for (size_t i = 0; i != s.size() / 2; ++i)
        if (s[i] != s[s.size() - i - 1])
            return false;
    return true;
}

// Чтобы лишней копии не создавалось, можно было бы передавать параметр по ссылке:

void is_palindrome(std::string& s);

// Но это опасно тем, что мы ненароком можем изменить s внутри функции и не заметить этого:

void is_palindrome(std::string& s) {
    for (size_t i = 0; i != s.size() / 2; ++i)
        if (s[i] = s[s.size() - i - 1]) // видите ошибку?
            return false;
    return true;
}

// Программа с такой ошибкой скомпилируется, запустится, но будет работать не так, как ожидается.


// Правильный способ - передавать параметр по константной ссылке.
// Модификатор const не позволяет изменять объект

void is_palindrome(const std::string& s) { // константная ссылка
    for (size_t i = 0; i != s.size() / 2; ++i)
        if (s[i] = s[s.size() - i - 1]) // теперь программа с такой ошибкой уже не скомпилируется
            return false;
    return true;
}

// Запомните: всегда передавайте объекты тяжелых типов (строки, контейнеры и т. д.) в функцию по константным ссылкам.
// если не требуется иное

